<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Accessible Draggable Switch — Demo</title>
  <style>
    /* Basic page layout */
    :root{
      --track-w: 64px;
      --track-h: 36px;
      --knob-size: 30px;
      --gap: calc((var(--track-h) - var(--knob-size)) / 2);
      --on-color: #22c55e; /* green */
      --off-color: #e5e7eb; /* gray-200 */
      --border: 1px solid rgba(0,0,0,0.08);
      --transition: 170ms cubic-bezier(.2,.9,.2,1);
    }

    html,body{height:100%;}
    body{
      font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
      display:flex;
      align-items:center;
      justify-content:center;
      background: #f8fafc;
      margin:0;
      padding:24px;
    }

    /* Switch container (role=switch element) */
    .switch{
      --translate: 0%; /* updated by JS */
      width: var(--track-w);
      height: var(--track-h);
      border-radius: calc(var(--track-h) / 2);
      background: var(--off-color);
      display:inline-grid;
      align-items:center;
      position:relative;
      padding: var(--gap);
      box-sizing:border-box;
      transition: background var(--transition), box-shadow var(--transition);
      cursor:pointer;
      user-select:none;
      touch-action: pan-y; /* allow vertical scrolling on touch while handling horizontal drags */
    }

    .switch[aria-checked="true"]{
      background: linear-gradient(90deg,var(--on-color), #16a34a);
      box-shadow: 0 4px 10px rgba(34,197,94,0.18);
    }

    /* The rail inside the track (for subtle outline) */
    .switch .rail{
      position:absolute;
      inset:0;
      border-radius:inherit;
      pointer-events:none;
    }

    /* The knob */
    .switch .knob{
      width: var(--knob-size);
      height: var(--knob-size);
      border-radius:50%;
      background:white;
      box-shadow: 0 1px 2px rgba(0,0,0,0.12), 0 6px 12px rgba(2,6,23,0.06);
      transform: translateX(var(--translate));
      transition: transform var(--transition) , box-shadow var(--transition);
      will-change: transform;
      position:relative;
      z-index:1;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:12px;
      color:#111827;
    }

    /* when dragging we reduce transition to zero so finger follows exactly */
    .switch.dragging .knob{
      transition: none;
      box-shadow: 0 6px 16px rgba(2,6,23,0.12);
    }

    /* focus styles for keyboard access */
    .switch:focus{
      outline: none;
      box-shadow: 0 0 0 4px rgba(59,130,246,0.14);
    }

    /* small label for demo */
    .demo-row{display:flex;gap:16px;align-items:center}
    .label{font-size:14px;color:#0f172a}

    /* Respect reduced motion */
    @media (prefers-reduced-motion: reduce){
      .switch, .switch .knob{transition:none}
    }
  </style>
</head>
<body>
  <div class="demo-row">
    <div class="label">Draggable switch</div>

    <!--
      Accessible switch element:
      - role="switch" and aria-checked reflect state
      - tabindex="0" makes it keyboard-focusable
      - JavaScript handles pointer dragging, clicks, and keyboard activation
    -->
    <div id="draggableSwitch" class="switch" role="switch" aria-checked="false" tabindex="0" aria-label="Enable feature">
      <div class="rail" aria-hidden="true"></div>
      <div class="knob" aria-hidden="true"> </div>
    </div>
  </div>

  <script>
    (function(){
      const switchEl = document.getElementById('draggableSwitch');
      const knob = switchEl.querySelector('.knob');

      const TRACK_WIDTH = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--track-w')) || 64;
      const TRACK_HEIGHT = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--track-h')) || 36;
      const KNOB_SIZE = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--knob-size')) || 30;

      // Convert CSS values (like "64px") to numbers if necessary
      function pxToNum(v){ return typeof v === 'string' ? parseFloat(v) : v }

      // We compute the min/max translate in px
      const trackW = pxToNum(getComputedStyle(switchEl).width);
      const knobSize = KNOB_SIZE;
      const gap = (trackW - knobSize) / 2; // left/right gap in px when centered vertically
      const minX = 0; // knob translate for OFF
      const maxX = trackW - knobSize - (gap * 0); // knob translate for ON; gap already applied by padding

      // we'll set translate in percentage to keep CSS variable simple
      function setTranslatePx(px){
        // clamp
        const clamped = Math.max(minX, Math.min(px, maxX));
        const percent = (clamped / (trackW - knobSize)) * 100;
        switchEl.style.setProperty('--translate', percent + '%');
      }

      // Helper to read boolean state
      function isOn(){ return switchEl.getAttribute('aria-checked') === 'true' }
      function setOn(on){
        switchEl.setAttribute('aria-checked', on ? 'true' : 'false');
        // set knob position to endpoints
        setTranslatePx(on ? (trackW - knobSize) : 0);
      }

      // Initialize position
      setOn(false);

      // Toggle on click (but not if the click resulted from a drag end where we already decided state)
      let dragging = false;
      let dragHandledClick = false;

      switchEl.addEventListener('click', (e)=>{
        if (dragHandledClick) { dragHandledClick = false; return }
        // toggle
        setOn(!isOn());
        // announce state (screen readers read aria-checked automatically)
      });

      // Keyboard support: Space/Enter toggle, ArrowLeft/Right to set
      switchEl.addEventListener('keydown', (e)=>{
        if (e.key === ' ' || e.key === 'Spacebar' || e.key === 'Enter'){
          e.preventDefault();
          setOn(!isOn());
        } else if (e.key === 'ArrowLeft' || e.key === 'Left'){
          e.preventDefault(); setOn(false);
        } else if (e.key === 'ArrowRight' || e.key === 'Right'){
          e.preventDefault(); setOn(true);
        }
      });

      // Pointer dragging (works for mouse, pen, touch) using Pointer Events API
      let pointerId = null;
      let startX = 0;
      let startTranslatePx = 0;

      function onPointerDown(e){
        // only primary button
        if (e.isPrimary === false) return;
        pointerId = e.pointerId;
        switchEl.setPointerCapture(pointerId);
        dragging = true;
        switchEl.classList.add('dragging');
        startX = e.clientX;
        // current translate in pixels
        const currentPercent = parseFloat(getComputedStyle(switchEl).getPropertyValue('--translate')) || 0;
        startTranslatePx = (currentPercent / 100) * (trackW - knobSize);

        // prevent click/select behaviour
        e.preventDefault();
      }

      function onPointerMove(e){
        if (!dragging || e.pointerId !== pointerId) return;
        const dx = e.clientX - startX;
        const newPx = startTranslatePx + dx;
        setTranslatePx(newPx);
      }

      function onPointerUp(e){
        if (!dragging || e.pointerId !== pointerId) return;
        dragging = false;
        switchEl.classList.remove('dragging');
        switchEl.releasePointerCapture(pointerId);
        pointerId = null;

        // Decide final state based on where the knob ended (midpoint rule)
        const currentPercent = parseFloat(getComputedStyle(switchEl).getPropertyValue('--translate')) || 0;
        const threshold = 50; // percent threshold to consider ON
        const finalOn = currentPercent >= threshold;
        setOn(finalOn);

        // If the user moved the pointer appreciably, prevent the following click from toggling twice
        if (Math.abs((currentPercent/100)*(trackW - knobSize) - startTranslatePx) > 4){
          dragHandledClick = true;
        }
      }

      // attach pointer events
      switchEl.addEventListener('pointerdown', onPointerDown);
      window.addEventListener('pointermove', onPointerMove);
      window.addEventListener('pointerup', onPointerUp);
      window.addEventListener('pointercancel', onPointerUp);

      // Resize observer — recalc sizes when layout changes (responsive)
      const ro = new ResizeObserver(()=>{
        // recompute track width and reposition knob according to current state
        const newTrackW = parseFloat(getComputedStyle(switchEl).width);
        // update internal trackW var by reassigning (closure uses const trackW above, but we can recompute values via function)
        // simply reapply setOn to snap to correct endpoint
        setOn(isOn());
      });
      ro.observe(switchEl);

      // Expose for debugging (optional)
      window._draggableSwitch = {
        el: switchEl,
        setOn
      };

    })();
  </script>
</body>
</html>
